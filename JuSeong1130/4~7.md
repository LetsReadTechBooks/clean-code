
## 4장

- 오해할 여지가 있는 주석은 아예 달지 않는게 좋다. 코드와 주석이 일맥상통해야한다라고 생각한다.
- 주석은 이해하는데 있어 독자에게 엄청난 이점이 생길 수 있다. 하지만 엄청나게 안좋은 상황으로 이끌 수 도 있다. 그래서 내 생각으로는 꼭 필요한 주석은 작성하고 나쁜코드는 트레이드 오프를 생각해서 남기는게 좋다 생각한다.  
- 프로그래머가 코드를 수정하면 주석도 바뀌어야한다. 만약 같이 바뀌지 않으면 예측하지 못하는 상황이 생길 수 있다.즉 이렇게 보면 주석도 비용이다. 그렇기 때문에 비용을 생각해서 남기는것이 좋은지 안남기는게 좋은지 잘 생각해봐야한다.
- 하지만 그런 상황이 아니라면 주석을 달지 않고 함수명 변수명을 통해 표현하는게 제일 좋을거같다. 보통 내가 생각하는 주석을 다는경우는 알고리즘이라면 어쩔 수 없고 이외의 상황이라면 한 함수에 너무 많은것을 담으려고 하는 상황인거같다. 그러므로 그때는 함수를 쪼개는 방법도 생각해보면 좋을거 같다.


## 5장
```
생각 사이에는 빈행을 넣어 분리한다. p98
```
빈행을 어디에다가 넣을지 고민이 있었는데 연관되어있는것들을 나눌때 빈행을 쓰게 된다라는 기준을 알게되었다. 여러 줄의 묶음은 완결된 생각 하나를 표현한다. 이것이 중요한거 같다.

```
가로로는 공백을 사용해 밀접/느슨한 개념을 표현한다
```
어떤것은 가로공백이 있고 어떤것은 없다. 그냥 보기에만 좋게 하려고 띄웠다 생각했지만 밀접 느슨한 개념이란것을 알게되었다.

101페이지 질문 이게바로 protected 변수를 피해야하는 이유중 하나다. protected ..?

## 6장

```
변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않는다 즉 구현을 감추려면 추상화가 필요하다. 
그저 조회함수(get)와 설정함수(set)로 변수를 다룬다고 클래스가 되지않는다. 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
```
  객사오에서 말한 추상화가 왜 중요한지 적절한 추상화를 통해 내부를 감추는 것이 중요하구나를 다시한번 깨달을 수 있었고 객체와 DTO의 차이를 확실히 알고 갈 수 있던 파트였습니다.

``` 
모듈은 자신이 조작하는 객체의 속사정을 몰라야한다. P123
```
객사오에서 말하는 인터페이스와 구현의 분리인거같습니다. 단순히 get을 가져오는게 아니라 적절한 추상화를 통한 메시지를 놨두고 그것을 가져오는게 좋다라는것을 다시한번 상기할 수 있었습니다.

또한 한 클래스가 있다면 어느정도까지 호출을 할 수 있을까란 고민이 있었는데 아래에서 말하는거 처럼 낯선사람은 무시해라라는 것을 알게되었고 묻지말고 시켜라와 많이 비슷하다 생각이 들게 되었습니다. 정말 중요한부분은 어느책이든 각자만의 스타일로 정의해놓았지만 내용은 같다는것을 느끼게 되었습니다.
<details>
<summary>책에서 말하는 디비터 법칙</summary>
<div markdown="1">

책에서 디미터 법칙은"클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다."라고 주장합니다.

1. 클래스 C: 메서드 f가 속한 클래스인 클래스 C의 메서드는 호출할 수 있습니다. 이것은 자명한 부분입니다.
    
2. f가 생성한 객체: 메서드 f가 새로 생성한 객체의 메서드를 호출할 수 있습니다. 즉, 메서드 f에서 객체를 생성한 경우 해당 객체의 메서드를 호출할 수 있습니다.
    
3. f 인수로 넘어온 객체: 메서드 f에 인수로 전달된 객체의 메서드를 호출할 수 있습니다. 즉, 메서드 f에게 인수로 전달된 객체에 대해서만 메서드 호출이 가능합니다.
    
4. C 인스턴스 변수에 저장된 객체: 클래스 C의 인스턴스 변수에 저장된 객체의 메서드를 호출할 수 있습니다. 이것은 클래스 C가 직접 관리하는 객체에 대한 메서드 호출을 허용합니다.

단 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안된다고한다. 낯선 사람은 경계하고 친구랑만 놀라는 의미다.

</div>
</details>

## 7장

```
try-catch-finally로 작성하면 try블록에 무슨일이 생기든지 호출하는 기대하는 상태를 정의하기 쉬워진다.
```

오류처리와 비즈니스로직을 분리하는것이 정말 좋다는 생각이 들었습니다. 오류처리 코드가 여기저기 흩어져있다면 유지보수가 정말 힘들것이라는 생각이 들었는데 이렇게 분리하는것을 통해 해결할 수 있구나를 알게되었습니다. 
(비즈니스로직은 추상화하여 한가지 메서드로하거나 가독성있게 표현하는게 좋다)

TDD의 내용 보여주면서 설명

```
미확인 예외를 사용하라
```
확인된 예외는 무조건 컴파일 단계에서 처리해줘야하지만 미확인예외는 선택적으로 처리해야한다는것으로 이해하고 넘어갔습니다.

```
오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
```
호출자를 고려해 예외클래스를 정의해라라는것인데 여기서 말하고자 하는것은 외부라이브러리를 쓸때 예외를 잡기위해 선언하는것들이 중복되고 한다면 Wrapper클래스로 감싸 이것을 해결하라라는것인거 같습니다. 즉 호출자가 추상화된 클래스만을 바라보고 예외는 한가지에만 의존하게 만드는것입니다.

외부라이브러리를 쓸때는 Wrapper 클래스를 이용한는것이 정말 좋다는 생각이 들었습니다. 즉 추상화(외부api가 추상화됨)를 통해 감싸지게 되니 세세하게 내부 구현을 몰라도 편리하게 사용가능하게 변하며 코드가 많이 줄어들어 깨끗해진다. 또한 재사용성이 좋아지게 되고 유지보수도 용이해진다. 

끄적

```
에외처리를 할때 만약 if else처럼 하는거라면 그냥 특수사례패턴을 써서 정상흐름을 만드는것이 좋다는 생각이 들었다.
```
```
null은 일거리를 늘리뿐만아니라 불필요한 작업을 떠넘길 뿐이다.
```
