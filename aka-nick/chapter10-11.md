## 10장 클래스

> 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체를 공개한다. 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다. 캡슐화를 풀어 주는 결정은 언제나 최후의 수단이다.  
> p172

> SuperDashboard는 메서드 수가 작음에도 불구하고 책임이 너무 많다.  
> 클래스 이름은 해당 클래스 책임을 기술 해야 한다. 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다.  
> ...  
> 또한 클래스 설명은 만일("if"), 그리고("and"), -(하)며("or"), 하지만("but")을 사용하지 않고서 25단어 내외로 가능해야 한다.  
> ...
> 'SuperDashboard는 마지막으로 포커스를 얻었던 컴포넌트에 접근하는 방법을 제공하며, 버전과 빌드 번호를 추적하는 메커니즘을 제공한다.' 첫 번째 '~하며,'는 SuperDashboard에 책임이 너무 많다는 증거다.  
> p175

>  우리들 대다수는 두뇌 용량에 한계가 있어 '깨끗하고 체계적인 소프트웨어' 보다 '돌아가는 소프트웨어'에 초점을 맞춘다. 전적으로 올바른 태도다.  
>  ...  
>  문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. 깨끗하고 체계적인 소프트웨어라는 다음 관심사로 전환하지 않는다.  
>  p176

> *응집도 Cohesion*  
> 클래스는 인스턴스 변수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.  
> 일반적으로 이처럼 응집도가 가장 높은 클래스는 가능하지도 바람직 하지도 않다. 그렇지만 우리는 응집도가 높은 클래스를 선호한다. 응집도가 높다는 말은 클래스가 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미이기 때문이다.  
> p177

> 원래 프로그램의 정확한 동작을 검증하는 테스트 슈트를 작성했다. 그런 다음, 한 번에 하나씩 수 차례에 걸쳐 조금씩 코드를 변경했다. 코드를 변경할 때마다 테스트를 수행해 원래 프로그램과 동일하게 동작하는지 확인했다. 조금씩 원래 프로그램을 정리한 결과 최종 프로그램이 얻어졌다.  
> p185

> 경험에 의하면 클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다. 하지만 실제로 개선에 뛰어드는 계기는 시스테밍 변해서라야 한다. Sql 클래스를 논리적으로 완성으로 여긴다면 책임을 분리하려 시도할 필요가 없다. 가까운 장래에 update문이 필요하지 않다면 Sql 클래스를 내버려두는 편이 좋다. 하지만 클래스에 손대는 순간 설계를 개선하려는 고민과 시도가 필요하다.  
> "(조금 다른 맥락이지만)개인적인 경험: '구조가 개선된다는 느낌'만으로 설계하지 않기."  
> p186 & 셀프메모

> 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다. 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.  
> p188

> 상세한 구현에 의존하는 코드는 테스트가 어렵다.  
> p189

> DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.  
> "사용하는 코드가 사용되는 코드를 직접 알지 않고 누군가가 알려주는 것."  
> p190 & 셀프메모

- 정리 및 느낀점
	- `private`을 "절대로" 풀면 안된다고 생각하고 있었는데, 왜 그런 생각을 갖고 있었는지 나도 모르겠다. 접근제어는 필요에 알맞은 수준으로 하면 된다.
	- 그러나 메시지 관점에서 잘 작성된 코드라면 캡슐화를 지키면서도 외부에서 원활히 사용할 수 있다는 생각도 든다.
	- 그러나! 당장 시스템 구조를 바꿀 수 없다면, 가능한 방법을 찾아가자. 섣불리 구조를 바꾸느니 접근제어를 (필요한 부분만)느슨하게 하는 편이 좋겠다고 생각한다.
	- 응집도라는 단어는 많이 들어봤지만 무슨 말인지 잘 몰랐다(사실 지금도 그렇다). 그래도 명확한 정의를 확인할 수 있어서 좋았다. 
	- 내가 이해하기로 객체 단위의 응집도는, 필드와 메서드의 연관성이 높아 모든 행위에서 최대한 사이드 이펙트를 일으키는 것을 말한다. 응집도가 높은 객체일 수록 살아있는 객체다.
	- 클래스 이름을 정하는 규칙에 대한 소개는 정말 신선했다.

## 11장 시스템

> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.  
> p195

> 현실적으로 한 객체 유형이 모든 문맥에 적합할 가능성이 있을까?  
> "절대 없다고 생각한다."  
> p196 & 셀프메모

> *Main 분리*  
> 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.  
> (그림 생략)  
> 제어 흐름은 따라가기 쉽다. main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.  
> p196

> *팩토리*  
> 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. (이후 생략)  
> p197

> *의존성 주입*  
> (내용 생략)  
> p198

> '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.  
> p199

> 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다.  
> p202

> AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.  
> p203

> 그렇다고 '아무 방향 없이' 프로젝트에 뛰어들어도 좋다는 소리는 아니다. 프로젝트를 시작할 때는 일반적인 범위, 목표, 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 한다. 하지만 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.  
> p210

> 최선의 시스템 구조는 각기 POJO (또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.  
> p211

> 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다.  
> p211

> 명백한 가치가 있을 때 표준을 현명하게 사용하라.  
> p211

> 나는 업계에서 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례를 많이 봤다.
> > 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.  
> p212

> 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여준다.  
> p212

> 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다.  
> p213

> 시스템을 설계하든 개별 모듈을 설계하든, **실제로 돌아가는 가장 단순한 수단**을 사용해야 한다는 사실을 명심하자.  
> p213

- 정리 및 느낀점
	- 이번에 테스트 코드를 만드는 것에 집중하여 공부하다 보니 몇 가지 깨달은 게 있었다. 생각들의 핵심은, 의존관계 구성과 구현 또한 분리되어야 할 관심사라는 생각이었다. 물론 책에서는 초기화까지(자세히는 초기화 시점과 방법까지도) 분리되어야 할 관심사로 이야기 한다.
	- 마침 읽은 이번 장이 내 생각에 동의를 해주는 것 같아서 뭔가 보람있었다.
	- POJO가 뭔지, 막연하게 알고 있었는데 좀 더 자세히 알아봐야 할 것 같다. 난 단순히, 외부 코드의 여파가 닿지 않는 자바 객체면 POJO인 줄 알았는데 그런것만은 아닌 것 같다.
