## 8장 경계

> Map이 반환하는 Object를 올바른 유형으로 변환할 책임은 Map을 사용하는 클라이언트에 있다. 그래도 코드는 동작한다. 하지만 깨끗한 코드라 보기는 어렵다.  
> p145

> 경계 인터페이스인 Map을 Sensors 안으로 숨긴다.  
> ...  
> 경계 인터페이스를 여기저기 넘기지 말라는 말이다. 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.  
> p146

> 외부 패키지 테스트가 우리 책임은 아니다. 하지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.  
> p146

> 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 짐 뉴커크(Jim Newkirk)는 이를 학습 테스트라 부른다.  
> 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.  
> p147

> (log4j의 사용법을 익히고 테스트하는 코드를 작성한 뒤) : 지금까지 간단한 콘솔 로거를 초기화하는 방법을 익혔으니, 이제 모든 지식을 독자적인 로거 클래스로 캡슐화한다. 그러면 나머지 프로그램은 log4j 경계 인터페이스를 몰라도 된다.  
> p149

> 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.  
> ...  
> 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.  
> p150

>(아직 존재하지 않는 코드를 사용하기 파트에서) : 우리는 (우리가 통제하지 못하며 정의되지도 않은) 송신기 API에서 CommunicationsController를 분리했다. 우리에게 필요한 인터페이스를 정의했으므로 CommunicationsController 코드는 깔끔하고 깨끗했다.  
>p151

> 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다.  
> p152

- 정리 및 느낀점
	- 외부 제공 인터페이스를 경계 인터페이스로 사용하는 경우(생성한 클래스 바깥으로 넘기는 경우), 외부 인터페이스의 변경 시 사용되는 모든 코드로 변경의 여파가 전달된다.  
	- 외부 인터페이스를 제어하는 경계 인터페이스를 사용자가 만들어서 사용하면(외부 인터페이스를 래핑한 일급컬렉션 객체), 해당 경계 인터페이스에서만 변경 여파를 감당하면 된다.
	- 아직 모르는(혹은 없는) 기능에 대해 학습 테스트를 작성하는 전략은 매우 좋은 것 같다. 바로 지금부터 적용해봐야겠다는 생각이 들었다.
	- (특히 외부와의)경계를 깔끔히 정리해야 변경 비용을 줄일 수 있다.
	- 어댑터 패턴에 대해 알아보아야겠다.

## 9장 단위 테스트

> 하지만 실제 코드와 맞먹을 정도의 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.  
> p155

> 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다.  
> p157

> (리팩토링 된 테스트케이스 코드 중 검증부) :   
 ```
assertResponseIsXML();  
assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", <name>childOne</name>"
);
 ```
 > 도메인에 특화된 언어DSL로 테스트 코드를 구현하는 기법을 보여준다. 흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다. 이렇게 구현한 함수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다. 즉, 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다.  
 > p160, 161
 
 > 이것이 이중 표준의 본질이다. 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다.  
 > p164
 
 > F.I.R.S.T : Fast(빠르게), Independent(독립적으로), Repeatable(반복가능하게), Self-Validating(자가검증하는), Timely(적시에)

- 정리 및 느낀점
	- TDD 좋다 좋다 하는 이야기를 하도 많이 들어서 '좋은가 보다' 하면서도 내가 직접 해보고 싶을 만큼의 강렬한 '이거야...!'를 느끼진 못했었다. 좋다는 사람들과 나의 감상 사이의 갭이 너무 커서, TDD에 대해 뭔가를 오해하고 있는지가 계속 의문이었다.
	- TDD에 가지고 있던 의문 하나가 첫페이지부터 나왔다 : '하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다. p155'.
	- 슬프게도, 다 읽었음에도 TDD가 그렇게나 강력한지는 아직 잘 모르겠다. 하지만 좋은 테스트를 작성하는 것에 대한 아이디어는 새롭게 얻었기 때문에 만족한다.

