## 4장 주석

4장은 1~3장 보다도 더욱 정보 전달 목적의 설명조가 짙다. 이해를 위해 요약할 만한 것이 없기 때문에, 4장이 언급하는 키워드 위주로 정리하고, 읽은 소감으로 마무리 한다.

- 좋은 주석의 종류
	- 법적인 주석 : 저작권, 소유권 등의 정보
	- 동작할 코드에 대한 자세한 정보
	- 코드의 의도를 설명 : 예를 들어 알고리즘처럼, 모르는 사람이 처음 봤을 때, 읽은 내용만을 가지고 바로 이해하기 어려운 내용이 있다면 부연 설명.
	- 의미 해석이 모호한 코드를 설명
	- 주의 사항을 경고하는 주석
	- TODO 주석 : IDE에서 관련 기능도 제공되므로 매우 편함
	- 중요성을 강조하는 주석 : 개인적으로는 '코드의 의도를 설명하는 주석'과 비슷하거나 크게 의미 없는 주석이라고 생각된다.
	- 공개 API 주석, Javadocs : 당연히 좋겠지?!
- 나쁜 주석의 종류
	- 주절거리는 주석 : 나만 알아듣는 주석. 주석 저자의 의도를 알기 위해 관련 코드를 열어봐야만 한다면, 주석이 없었어도 똑같은 상황이었을 테니 결국 쓸모없는 주석이다. 주석의 의미를 파악하는데 시간이 들어서 오히려 더욱 낭비.
	- 코드를 *있는 그대로* 설명하는 주석 : 단순 동어 반복이라면 독해 자원만 낭비된다.
	- 아예 틀린것도 아니고 미묘하게 부정확해서 부작용을 낳는 주석
	- 필요없는 설명 : 예를 들면, 버전 관리 주석(버전 관리 시스템을 안쓴다면 모를까), 코드로 설명이 되는 주석 등.
	- 위치를 표시하는 주석 : 항상 쓸모없는 건 아니지만 너무 많이 반복되면 가독을 방해하고 종국에는 주석이 주목을 끌지 못하게 된다. 
	- 사용하지 않게된 주석 : 코드 임시 주석은 다시 주석을 해제할 것인지/지울 것인지, 지울 거라면 언제 지울 것인지, 참고하기 위해 영원히 남겨놓아야 하는지 판단이 필요하다. 사용되지 않는 코드면 가급적 지우고, 설명을 남겨놔야 하는 코드라면 코드 대신 설명문으로 뜻을 명확히 남겨두자.
	- HTML 코드 : 보기 싫은건 이해한다. 근데 이건 Javadoc이 IDE에서 가독성 있게 보이려고 삽입하는 경우가 있다. Javadoc이 마크다운과 같은 포맷은 지원하지 않고 HTML만 지원하기 때문에, 개인적으로는 예외에 해당한다 생각한다.
	- 전역적인 정보 : 전역적인 정보를 단지 하나의 기능일 뿐인 코드 위에 기술하는 것은 범위의 오류다.
	- 비공개 코드의 Javadocs : 공개하지 않을 API에는 API문서가 필요하지 않다.
- 정리 및 느낀점
	- 주석 또한 코드라고 생각하면 편한 것 같다. 
	- 코딩에서 불필요한 코드는 제외한다. 필요한 코드는 추가한다. 의미는 명확하게 한다. 간결하게 표현한다.
	- 주석을 작성할 때는 불필요한 내용은 제외하고 필요한 내용만 간결하게 명확하도록 의미를 전달하려고 노력해야 한다.

## 5장 형식 맞추기
- 형식을 맞추는 건 의사소통의 비용을 낮추는 일환이다.
- 고려할 점
	- 코드라인의 수 : 200줄 이하
	- 중요한 내용이 앞에 드러나도록
	- 개념과 개념 사이에 공백 행을 넣어서 분리(예를 들어 메서드 사이)
	- 연관 있는 변수와 메서드는 근접하게 두기. 종속 관계가 있다면 상위 개념을 위에 둔다.
	- 한 행의 길이 : 80줄 이하(개인적으로는 100~120줄 정도가 적당하다고 생각한다...라고 적었는데 책에서도 괜찮다고 한다)
	- 블록의 들여쓰기를 무시하지 말자
	- 빈 while문이나 for문을 작성하지 말자. 차라리 빈 블록을 만들자.
	- 팀 단위로 일한다면 팀 규칙을 우선하자.
- 정리 및 느낀점
	- 개인적으로 지키고 있는 규칙이 있다: if, while, for 등의 블록을 생략하면 안된다고 생각한다. 단항연산의 경우만 예외로 하고 있다.
	```
	if (isTrue) { // 가능
		count++;
	}
	if (isTrue) count++; // 가능
	if (isTrue) { // 가능
		count += 10;
	}
	if (isTrue) count += 10; // 불가능
	```
	- 전반적으로 공감되는 내용이 많았다. 규칙의 내용도 내용이지만, **규칙이 필요하다는 사실**이 가장 공감이 된다. 
	- 같은 동작을 하는 코드라면, 다른 두 사람이 작성하더라도 같은 형태로 나올 수 있어야 한다. 쉽게 말하는 것이 그랬듯, '같게 말하는 것' 또한 인지 장벽을 낮추는 일이다.

## 객체와 자료 구조
> 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 
> p119  

> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.  
> p122

> "'FluentAPI가 데메테르 법칙 위반인가?' 라는 의문에 대해 생각하다가: 데메테르 법칙(이하 '법칙')을 지키든 안 지키든, 메서드를 통해 연관 객체를 탐색하는 경우에는 의존성이 생기는 건 마찬가지다. 법칙을 지켰을 경우에는 명시적으로 의존성이 나타나고 위반했을 때는 암시적으로 의존성이 존재할 뿐이다."  
> p124 셀프메모

> 위 예제가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.  
> p124  
> "자료구조라고 내부 구조를 public하게 접근하는 것을 허용하는 것이 옳은가 하면 여전히 100% 동의할 수는 없다. '그러면 무엇이 좋은 방법인가'라는 질문에 대답할 수 없을 지라도 말이다."

> 활성 레코드는 DTO의 특수한 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.  
> 불행히도 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하다. 하지만 이는 바람직하지 않다. 그러면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문이다.

> 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.  
> p128

- 정리 및 느낀점
	- 객체냐 자료구조냐를 잘 판단하자. 그리고 결국 구현은 요구사항(시스템/비즈니스)에 따라 정해진다.

## 7장 오류 처리

> 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리했기 때문이다.  
> p132

> 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.  
> p133

> 확인된 예외는 OCP를 위반한다.  
> p134

> **null을 반환하지 마라. null을 전달하지 마라.**  
> p138, 140

- 정리 및 느낀점
	- 자바도 다른 언어들도 많이 발전해서 null이나 예외를 처리하는 여러 대안을 만들었다.
	- 하지만 그럼에도 완전하지 않기 때문에(특히 자바는), 충분히 주의해서 다룰 필요가 있겠다.
