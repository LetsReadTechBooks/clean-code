# 클린코드 한줄 모음 및 정리

`""`로 묶이고 끝에 '셀프메모'라고 설명을 덧붙여진 문장은 개인적인 메모로, 책에는 없는 내용이다.  
각 파트는 밑줄 그은 부분을 모은 것과 정리 또는 느낀점을 모은 부분으로 나뉘어 있다.

## 1장 깨끗한 코드

> 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기 때문에 **코드는 문학적으로 표현해야 마땅하다**.
> p11

- (전부터 늘 가지고 있던 생각이기도 한데)코드 작성과 글쓰기는 많은 부분이 닮아있는 작업이다. 
- 단순한 나열만으로 정보를 전달할 수 있다면 문학이란 것은 존재 이유가 없다. 단어의 나열만으로 풍부한 의사소통이 가능하다면 우리는 지금도 원시시대 원주민처럼 단어만으로 의사를 전달했을 것이다. 
- 장황한 설명으로 정보를 정확히 전달할 수 있다면 '조리있다'는 표현이 존재할 이유가 없다. 콜라와 커피 중에서 뭘 먹을 건지 설명하기 위해 나의 출생지, 가족 관계, 취미와 특기, 좋아하는 영화 등을 세 시간 정도 설명한다면 그게 음료수를 고르는 건지 본인의 탄생 설화를 읊는 건지 알 수가 없을 것이다.
- 문단이 전달하고자 하는 바는 문단에 포함된 모든 문장들이 잘 표현하고 있어야 한다. 관련없는 문장은 버려져야 한다. 문장이 전달하고자 하는 바는 단어들이 잘 표현하고 있어야 하고 관련없는 단어는 버려져야 한다. 단어와 문장은 가급적 서로의 의미와 의도를 더 잘 설명할 수 있는 것으로 세심히 골라야 한다. 즉, (코드든 글이든)우리 손에서 작성된 것은 간결하게 표현하고자 하는 바를 잘 나타내야 한다.

## 2장 의미 있는 이름

> 문제는 코드의 단순성이 아니라 코드의 함축성이다. 다시 말해, 코드 맥락이 코드 자체에 명시적으로 드러나지 않는다.
> p23

> "(글이란게 본래 그렇지만 코드에서도)모든 단어와 문장은 맥락을 함축적으로 표현해야 한다."
> p23 셀프메모

> 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다는 문제점이 있다.
> p28

> "변수의 사용 범위에 따라 이름의 길이가 정해진다는 부분에서: 변수의 사용 범위에 따라 이름의 길이가 정해진다는 건 일견 그럴듯 하다. 아마도 매우 지루한 코드만 작성할 경우에는 맞는 말일 것이다.
> 실제로는 작성된 코드가 매우 길어도 순차적으로 뭔가 수행할 뿐인 구현도 있고, 짧지만 복잡한 로직과 실행 순서를 가지는 경우도 있다. 또, 짧은 메서드에 작성된 변수지만 해당 메서드가 연관된 수많은 메서드 호출 체이닝의 일부인 경우에는 어떨 것인가? 이 메서드는 짧지만 이 메서드의 **문맥은 길다**.
> 변수의 이름이 충분히 구체적인 맥락을 전달해야 하는 이유는, 복잡한 코드를 읽다가 변수의 맥락을 잃더라도, 변수가 다시 등장할 때 그 이름을 통해서 맥락을 다시 얻으려는 목적이다."
> p28 셀프메모

> "루프 변수는 i, j, k 등을 허용한다는 부분에서: 담을 의미가 있는 경우라면, 루프 변수도 의미를 담는게 좋다고 생각한다."
> p31 셀프메모

> 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다.
> p31

> 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다.
> p33

> 한 단어를 두 가지 목적으로 사용하지 마라.
> p34

> "의미있는 맥락을 추가하기 위한 접두어 부분에서: 적어도 OOP 안에서는, 맥락을 추가하기 위해 상태에 접두어를 붙일 필요는 적을 것 같다. 상태가 올바르게 추가된 상황이라면, 예제의 `state(주소지 중 주)`는 `Address#state()`와 같이 표현되었을 거라고 생각한다. 그 정도면 충분히 설명이 된다고 본다.
> 정말 필요할만한 상황을 상상해보자면, 단독 파라미터로 `state`만 넘어오는 경우를 생각해볼 수 있겠다. 이때는 `addrState`라고 명명하는 걸 고려하겠다. 정말 그런 경우가 있다면 생각은 해보겠다. 하지만 그땐 `AddressState` 타입을 정의하는 것도 함께 고려하지 않을까?😅"
> p35 셀프메모

- 1장의 정리와 일맥상통하다.
- 그러나 2장을 읽으면서는 동의할 수 없는 부분도 많이 있었다. 하지만 중요한 건 세부적인 지침에 따르냐 마냐가 아니라, 결국 코드를 읽는 사람(개발자)에게 얼마나 효율적으로 맥락을 제공하느냐인 것 같다.
- 이를 위한 여러 스킬을 저자로부터 공유받을 수 있었는데, 코드 작성 스킬에 대한 이야기였지만, 설계에 대한 생각으로 뻗어나가게 되는 부분이 종종 있어서 흥미로웠다.

## 3장 함수

> 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
> ...
> 즉, 위에서 아래로 프로그램을 읽어면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 나는 이것을 내려가기 규칙이라 부른다.
> p46

> 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 왜냐고? 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까! 플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까!
> p52

> 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까.
> p54-55

> "한 객체 안에서 모든 문맥을 가독성 있게 표현하려는 것 자체가 무리일 수도 있다. 적어도 별개의 객체, 또는 계층으로 나누는 것이 유효할 수도 있다."
> p62 셀프메모

- 추상팩토리가 뭔지 몰라서 찾아보는 시간이 있었다.
- boolean 플래그에 대한 내용은 생각지 못했던 부분인데 크게 공감이 되었다.
- 2장과 더불어, 설계(특히 계층)에 대해 생각할 부분이 많았던 것 같다.

### 스터디 후 추가
스터디 후 설명하면서 기억해두면 좋을 점이 나와서 기록해둔다. 혹시나 다시 보았을 때 맥락을 잊어서 이해가 어렵다면 결론만 참고하자.
- 함수 당 기능은 하나만 동작하라는 파트('한 가지만 해라!')가 있다. 이 말은 크게 두 가지로 해석될 여지가 있다. 
	- 첫번째. 말 그대로, 하나의 기능만 하는 것이 바람직하다(`appendStringAndTrim()` 같은건 피하라는 의미). 이 의도는 그대로 받아들여도 무방하다 생각된다. 옳고 그름을 떠나서 오해의 여지는 없을 듯 하다는 의미다.
	- 두번째. 한 기능을 구현하는 여러 추상화 수준의 코드를 한데 섞지 마라. 근데 이 의도는 여차하면 이런 오해를 살 수 있다. 
		- '하나의 요구사항'을 해결하는 기능이라면 '한 가지 기능'을 가진 코드 아닌가? 같이 두는게 왜 문제?
- 코드를 요구사항을 해결하는 기능적인 측면으로만 다가간다면, 극단적으로는 프로그래머가 작성한 모든 코드가 한 가지 기능-어떤(해당) 프로그램의 실행-만을 위해 동작한다고 말할 수도 있다. 말이 안되는 억지라는 걸 안다. 반대로 말하면, 기능적으로만 보는건 억지라는 것이다.
- 많은 프로그래머가 요구사항을 핸들링하는 코드와 그것을 구체적으로 구현하는 코드는 별개의 추상화 수준을 갖는다고 인식한다. 코드의 추상화 수준을 분리한 것은, 추상화 과정에서 마땅히 별개로 분리함이 마땅한 별개의 기능이란 것을 인식했기 때문이다. 맞다. 분리할 수 있는 기능은 별개의 기능이다, 분리가 되면 별개니까! 그런데 그것을 구현 과정에서 한 함수에 합치면? 그것은 여전히 하나의 기능을 처리하는 코드겠지만, 위의 맥락에서 여러 기능을 처리하는 함수가 된다.
- 결론 : *한 가지만 해라* 파트는 한 파트에서 두 가지 의미를 전달해서 혼동을 주고 있다. 내가 누군가에게 이 개념을 설명해야 한다면, 오해를 피할 수 있도록 *두 개념을 두 개의 문장*으로 설명하겠다.
	- 한 함수는 하나의 요구사항만 처리하자.
	- 추상화 수준을 섞은 코드를 작성하면, 하나의 요구사항을 처리하고 있는지 알기 어렵다.

## 4장 주석

4장은 1~3장 보다도 더욱 정보 전달 목적의 설명조가 짙다. 이해를 위해 요약할 만한 것이 없기 때문에, 4장이 언급하는 키워드 위주로 정리하고, 읽은 소감으로 마무리 한다.

- 좋은 주석의 종류
	- 법적인 주석 : 저작권, 소유권 등의 정보
	- 동작할 코드에 대한 자세한 정보
	- 코드의 의도를 설명 : 예를 들어 알고리즘처럼, 모르는 사람이 처음 봤을 때, 읽은 내용만을 가지고 바로 이해하기 어려운 내용이 있다면 부연 설명.
	- 의미 해석이 모호한 코드를 설명
	- 주의 사항을 경고하는 주석
	- TODO 주석 : IDE에서 관련 기능도 제공되므로 매우 편함
	- 중요성을 강조하는 주석 : 개인적으로는 '코드의 의도를 설명하는 주석'과 비슷하거나 크게 의미 없는 주석이라고 생각된다.
	- 공개 API 주석, Javadocs : 당연히 좋겠지?!
- 나쁜 주석의 종류
	- 주절거리는 주석 : 나만 알아듣는 주석. 주석 저자의 의도를 알기 위해 관련 코드를 열어봐야만 한다면, 주석이 없었어도 똑같은 상황이었을 테니 결국 쓸모없는 주석이다. 주석의 의미를 파악하는데 시간이 들어서 오히려 더욱 낭비.
	- 코드를 *있는 그대로* 설명하는 주석 : 단순 동어 반복이라면 독해 자원만 낭비된다.
	- 아예 틀린것도 아니고 미묘하게 부정확해서 부작용을 낳는 주석
	- 필요없는 설명 : 예를 들면, 버전 관리 주석(버전 관리 시스템을 안쓴다면 모를까), 코드로 설명이 되는 주석 등.
	- 위치를 표시하는 주석 : 항상 쓸모없는 건 아니지만 너무 많이 반복되면 가독을 방해하고 종국에는 주석이 주목을 끌지 못하게 된다. 
	- 사용하지 않게된 주석 : 코드 임시 주석은 다시 주석을 해제할 것인지/지울 것인지, 지울 거라면 언제 지울 것인지, 참고하기 위해 영원히 남겨놓아야 하는지 판단이 필요하다. 사용되지 않는 코드면 가급적 지우고, 설명을 남겨놔야 하는 코드라면 코드 대신 설명문으로 뜻을 명확히 남겨두자.
	- HTML 코드 : 보기 싫은건 이해한다. 근데 이건 Javadoc이 IDE에서 가독성 있게 보이려고 삽입하는 경우가 있다. Javadoc이 마크다운과 같은 포맷은 지원하지 않고 HTML만 지원하기 때문에, 개인적으로는 예외에 해당한다 생각한다.
	- 전역적인 정보 : 전역적인 정보를 단지 하나의 기능일 뿐인 코드 위에 기술하는 것은 범위의 오류다.
	- 비공개 코드의 Javadocs : 공개하지 않을 API에는 API문서가 필요하지 않다.
- 정리 및 느낀점
	- 주석 또한 코드라고 생각하면 편한 것 같다. 
	- 코딩에서 불필요한 코드는 제외한다. 필요한 코드는 추가한다. 의미는 명확하게 한다. 간결하게 표현한다.
	- 주석을 작성할 때는 불필요한 내용은 제외하고 필요한 내용만 간결하게 명확하도록 의미를 전달하려고 노력해야 한다.

## 5장 형식 맞추기
- 형식을 맞추는 건 의사소통의 비용을 낮추는 일환이다.
- 고려할 점
	- 코드라인의 수 : 200줄 이하
	- 중요한 내용이 앞에 드러나도록
	- 개념과 개념 사이에 공백 행을 넣어서 분리(예를 들어 메서드 사이)
	- 연관 있는 변수와 메서드는 근접하게 두기. 종속 관계가 있다면 상위 개념을 위에 둔다.
	- 한 행의 길이 : 80줄 이하(개인적으로는 100~120줄 정도가 적당하다고 생각한다...라고 적었는데 책에서도 괜찮다고 한다)
	- 블록의 들여쓰기를 무시하지 말자
	- 빈 while문이나 for문을 작성하지 말자. 차라리 빈 블록을 만들자.
	- 팀 단위로 일한다면 팀 규칙을 우선하자.
- 정리 및 느낀점
	- 개인적으로 지키고 있는 규칙이 있다: if, while, for 등의 블록을 생략하면 안된다고 생각한다. 단항연산의 경우만 예외로 하고 있다.
	```
	if (isTrue) { // 가능
		count++;
	}
	if (isTrue) count++; // 가능
	if (isTrue) { // 가능
		count += 10;
	}
	if (isTrue) count += 10; // 불가능
	```
	- 전반적으로 공감되는 내용이 많았다. 규칙의 내용도 내용이지만, **규칙이 필요하다는 사실**이 가장 공감이 된다. 
	- 같은 동작을 하는 코드라면, 다른 두 사람이 작성하더라도 같은 형태로 나올 수 있어야 한다. 쉽게 말하는 것이 그랬듯, '같게 말하는 것' 또한 인지 장벽을 낮추는 일이다.

## 객체와 자료 구조
> 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 
> p119  

> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.  
> p122

> "'FluentAPI가 데메테르 법칙 위반인가?' 라는 의문에 대해 생각하다가: 데메테르 법칙(이하 '법칙')을 지키든 안 지키든, 메서드를 통해 연관 객체를 탐색하는 경우에는 의존성이 생기는 건 마찬가지다. 법칙을 지켰을 경우에는 명시적으로 의존성이 나타나고 위반했을 때는 암시적으로 의존성이 존재할 뿐이다."  
> p124 셀프메모

> 위 예제가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.  
> p124  
> "자료구조라고 내부 구조를 public하게 접근하는 것을 허용하는 것이 옳은가 하면 여전히 100% 동의할 수는 없다. '그러면 무엇이 좋은 방법인가'라는 질문에 대답할 수 없을 지라도 말이다."

> 활성 레코드는 DTO의 특수한 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.  
> 불행히도 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하다. 하지만 이는 바람직하지 않다. 그러면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문이다.

> 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.  
> p128

